// ======= ç”¨æˆ·å…³é”®è¯è®¾ç½® =======
const blockedNameKeywords = ["lucy", "jessica"];
const blockedGeneralKeywords = ["crypto", "bot"];
const targetNameKeywords = ["mike", "tom", "jack"];
const targetGeneralKeywords = ["developer", "engineer", "react"];

// ======= å·¥å…·å‡½æ•° =======
function matchWholeWord(text, keywords) {
  const lower = text.toLowerCase();
  return keywords.some(w => new RegExp(`\\b${w}\\b`, "i").test(lower));
}
function matchSubstring(text, keywords) {
  const lower = text.toLowerCase();
  return keywords.some(w => lower.includes(w.toLowerCase()));
}
function extractUsername(text) {
  const match = text.match(/@([\w\-\.]+)\.bsky\.social/);
  return match ? match[1].toLowerCase() : "";
}
function normalize(text) {
  return text.toLowerCase().trim();
}

// ======= çŠ¶æ€æ§åˆ¶ =======
let followCount = 0;
let isPaused = true;
const processedUsers = new Set();
const followQueue = [];

// ======= ç²¾å‡†æ¸…é™¤å¤´åƒ background-image =======
function clearAvatarBackgrounds() {
  const avatars = document.querySelectorAll('div[style*="background-image"][class*="css-g5y9jx"]');
  avatars.forEach(div => {
    div.style.backgroundImage = 'none';
  });
}

// ======= åŠ¨æ€ç›‘å¬å¤´åƒåŠ è½½è‡ªåŠ¨æ¸…é™¤ =======
const avatarObserver = new MutationObserver(clearAvatarBackgrounds);
avatarObserver.observe(document.body, { childList: true, subtree: true });

// ======= è·å–ç”¨æˆ·èµ„æ–™ API =======
async function getProfileData(handle) {
  if (!handle || handle.startsWith("did:")) return null;
  try {
    const url = `https://public.api.bsky.app/xrpc/app.bsky.actor.getProfile?actor=${handle}`;
    const res = await fetch(url);
    if (!res.ok) return null;
    return await res.json();
  } catch (err) {
    console.error(`ğŸš¨ è·å–ç”¨æˆ· ${handle} çš„èµ„æ–™å¤±è´¥`, err.message || err);
    return null;
  }
}

// ======= å¡ç‰‡å¤„ç†é€»è¾‘ï¼ˆå»¶è¿Ÿåˆ¤æ–­ï¼‰=======
async function handleCard(card, retry = 0) {
  try {
    if (card.dataset.processed || isPaused) return;

    const cardText = card.innerText;
    if (!cardText || cardText.length < 10) {
      if (retry < 3) return setTimeout(() => handleCard(card, retry + 1), 150);
      return;
    }

    const nickMatch = cardText.match(/^(.*?)\n@/);
    const nickname = nickMatch ? normalize(nickMatch[1]) : "";
    const username = extractUsername(cardText);
    const bioText = cardText.replace(nickMatch?.[0] || "", "").replace(/@\w+\.bsky\.social/, "").trim();
    const hasBio = bioText.length > 0;

    if (!username || processedUsers.has(username)) return;
    card.dataset.processed = "true";
    processedUsers.add(username);

    if (
      matchSubstring(nickname, blockedNameKeywords) ||
      matchSubstring(username, blockedNameKeywords) ||
      (hasBio && matchWholeWord(bioText, blockedGeneralKeywords))
    ) {
      console.warn(`â›”ï¸ Blocked: ${nickname} (${username})`);
      return;
    }

    let matched = false;
    if (hasBio) {
      if (
        matchSubstring(nickname, targetNameKeywords) ||
        matchSubstring(username, targetNameKeywords) ||
        matchSubstring(bioText, targetGeneralKeywords)
      ) matched = true;
    } else {
      if (
        matchSubstring(nickname, targetNameKeywords) ||
        matchSubstring(username, targetNameKeywords) ||
        matchSubstring(nickname, targetGeneralKeywords) ||
        matchSubstring(username, targetGeneralKeywords)
      ) matched = true;
    }

    if (!matched) {
      console.log(`ğŸŸ¤ Skipped: ${nickname} (${username}) ä¸ç¬¦åˆç›®æ ‡å…³é”®è¯`);
      return;
    }

    const fullHandle = username.includes('.') ? username : `${username}.bsky.social`;
    const profile = await getProfileData(fullHandle);
    if (!profile) return;

    const { followersCount = 0, followsCount = 0 } = profile;
    if (followersCount < 500 && followsCount < 500) {
      card._followBtn = card._followBtn || card.querySelector('button[aria-label="Follow"], button[aria-label="å…³æ³¨"]');
      if (card._followBtn) {
        followQueue.push({ btn: card._followBtn, card });
        console.log(`ğŸ”œ Enqueued follow: ${nickname} (${username}) ç²‰ä¸ ${followersCount} / å…³æ³¨ ${followsCount}`);
      }
    } else {
      console.log(`â›”ï¸ Skipped (ç²‰ä¸/å…³æ³¨é«˜): ${nickname} (${username}) ç²‰ä¸ ${followersCount} / å…³æ³¨ ${followsCount}`);
    }

  } catch (err) {
    console.error("ğŸš¨ handleCard é”™è¯¯", err);
  }
}

// ======= æ‰«æå¹¶å¤„ç†æ‰€æœ‰å¡ç‰‡ =======
function processAllCards() {
  if (isPaused) return;
  const allCards = Array.from(document.querySelectorAll('div[style*="padding"][style*="border-top-width"]'));
  const unprocessedCards = allCards.filter(card => !card.dataset.processed);
  for (const card of unprocessedCards) {
    handleCard(card);
  }
}

// ======= è‡ªåŠ¨ç‚¹å‡»å…³æ³¨é˜Ÿåˆ— =======
async function dequeueFollow() {
  if (isPaused || followQueue.length === 0) {
    setTimeout(dequeueFollow, 500);
    return;
  }

  const { btn } = followQueue.shift();
  try {
    btn.click();
    followCount++;
    counterBox.innerText = `âœ… Followed: ${followCount}`;
    console.log(`âœ… Followed`);
  } catch (e) {
    console.warn("âš ï¸ Follow failed", e);
  } finally {
    setTimeout(dequeueFollow, 100);
  }
}
dequeueFollow();

// ======= è§‚å¯Ÿé¡µé¢å˜åŒ–ï¼Œè‡ªåŠ¨è§¦å‘å¤„ç† =======
const observer = new MutationObserver(() => {
  if (!isPaused) {
    setTimeout(processAllCards, 200);
  }
});
observer.observe(document.body, { childList: true, subtree: true });

// ======= æ¯0.5ç§’é—ªç°åˆ°åº•éƒ¨ =======
setInterval(() => {
  if (!isPaused) {
    window.scrollTo({ top: document.body.scrollHeight });
  }
}, 500);

// ======= UI çŠ¶æ€æ¡† =======
const counterBox = document.createElement("div");
Object.assign(counterBox.style, {
  position: "fixed", bottom: "20px", right: "20px",
  backgroundColor: "#222", color: "#0f0", padding: "10px 15px",
  borderRadius: "8px", fontSize: "14px", zIndex: "9999",
  boxShadow: "0 0 8px rgba(0,0,0,0.5)", display: "none"
});
counterBox.innerText = `âœ… Followed: 0`;
document.body.appendChild(counterBox);

// ======= å¿«æ·é”®æ§åˆ¶ï¼ˆRå¯åŠ¨/Qæš‚åœï¼‰=======
alert("ğŸŸ¡ è‡ªåŠ¨å…³æ³¨å·²å°±ç»ªï¼ŒæŒ‰ R å¼€å§‹ï¼ŒæŒ‰ Q æš‚åœ");
document.addEventListener("keydown", (e) => {
  const key = e.key.toLowerCase();
  if (key === "q") {
    isPaused = true;
    counterBox.style.display = "none";
    console.log("â¸ å·²æš‚åœè‡ªåŠ¨å…³æ³¨");
  } else if (key === "r") {
    isPaused = false;
    counterBox.style.display = "block";
    console.log("â–¶ï¸ å·²æ¢å¤è‡ªåŠ¨å…³æ³¨");

    clearAvatarBackgrounds(); // âœ… ç²¾å‡†æ¸…é™¤å¤´åƒ background
    processAllCards();
  }
});
